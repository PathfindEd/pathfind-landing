<script>
    let currentPage = 1;
    const totalPages = 4;
    const form = document.querySelector('form[name="consultation"]');
    const submitButton = document.getElementById('final-submit-button');

    function updateFormVisibility() {
        // Hide all pages
        document.querySelectorAll('.form-page').forEach(page => {
            page.classList.add('hidden');
        });
        // Show the current page
        const currentPageElement = document.getElementById(`page-${currentPage}`);
        if (currentPageElement) {
            currentPageElement.classList.remove('hidden');
        }

        // Update progress indicator
        document.querySelectorAll('.step').forEach((step, index) => {
            step.classList.remove('active');
            if (index + 1 <= currentPage) {
                step.classList.add('active');
            }
        });
        
        // Scroll to top of form ONLY when changing pages, NOT on submit
        if(document.querySelector('.form-container')) {
            document.querySelector('.form-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    function nextPage(fromPage) {
        const currentFieldset = document.getElementById(`page-${fromPage}`);
        let isValid = validateFieldset(currentFieldset); // Use helper function

        if (isValid && currentPage < totalPages) {
            currentPage++;
            updateFormVisibility();
        } else if (!isValid) {
            scrollToFirstError(currentFieldset);
        }
    }

    function prevPage(fromPage) {
        if (currentPage > 1) {
            currentPage--;
            updateFormVisibility();
        }
    }

    // Helper function to validate a specific section (reused for Next and Submit)
    function validateFieldset(fieldset) {
        let isValid = true;
        let firstInvalidInput = null;

        // Clear previous error states
        fieldset.querySelectorAll('input, select, textarea').forEach(input => {
            input.style.borderColor = 'var(--light-gray)'; 
        });
        fieldset.querySelectorAll('.radio-group, #consent-label').forEach(el => {
            el.style.border = 'none';
            el.style.padding = el.id === 'consent-label' ? '12px' : '10px'; 
            el.style.backgroundColor = 'transparent';
        });

        // Run checks
        fieldset.querySelectorAll('[required]').forEach(input => {
            let isInputValid = true;
            
            if (input.type === 'radio') {
                const radioName = input.name;
                if (!document.querySelector(`input[name="${radioName}"]:checked`)) {
                    isInputValid = false;
                }
            } else if (input.type === 'checkbox') {
                if (!input.checked) {
                    isInputValid = false;
                }
            } else if (input.type === 'file') {
                if (input.files.length === 0) {
                    isInputValid = false;
                }
            } else if (!input.value.trim()) {
                isInputValid = false;
            }

            if (!isInputValid) {
                isValid = false;
                // Apply visual error state
                if (input.type === 'checkbox' && input.id === 'data_processing_consent') {
                    const consentLabel = document.getElementById('consent-label');
                    consentLabel.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                    consentLabel.style.border = '1px solid red';
                    if (!firstInvalidInput) firstInvalidInput = consentLabel;
                } else if (input.type === 'radio') {
                    const radioGroup = document.querySelector(`input[name="${input.name}"]`).closest('.radio-group');
                    if (radioGroup) {
                        radioGroup.style.border = '1px solid red';
                        radioGroup.style.padding = '10px';
                    }
                    if (!firstInvalidInput) firstInvalidInput = radioGroup;
                } else {
                    input.style.borderColor = 'red';
                    if (!firstInvalidInput) firstInvalidInput = input;
                }
                // Tag the input so we can find it later
                input.dataset.invalid = "true";
            } else {
                 delete input.dataset.invalid;
            }
        });
        
        return isValid;
    }

    function scrollToFirstError(fieldset) {
        // Find first element we marked as invalid
        const firstInvalid = fieldset.querySelector('[data-invalid="true"]') || fieldset.querySelector(':invalid');
        // Special handling for the consent label or radio groups which might be the "parent" of the input
        if (firstInvalid) {
            // Check if it's the consent checkbox, scroll to its label instead
            if (firstInvalid.id === 'data_processing_consent') {
                 document.getElementById('consent-label').scrollIntoView({ behavior: 'smooth', block: 'center' });
            } 
            // Check if it's a radio button, scroll to its group
            else if (firstInvalid.type === 'radio') {
                 firstInvalid.closest('.radio-group').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            else {
                 firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }

    // --- NEW SUBMISSION HANDLER ---
    form.addEventListener('submit', function(event) {
        const currentFieldset = document.getElementById('page-4');
        
        // 1. Run your custom validation (for red borders)
        const isCustomValid = validateFieldset(currentFieldset);
        
        // 2. Run browser native validation
        const isNativeValid = form.checkValidity();

        if (isCustomValid && isNativeValid) {
            // SUCCESS: Disable button to prevent double-submit
            submitButton.disabled = true;
            submitButton.textContent = 'Submitting... Please wait.';
            submitButton.classList.add('submitting');
            // Allow the form to submit naturally to the Worker URL
        } else {
            // ERROR: Stop submission and show errors
            event.preventDefault();
            scrollToFirstError(currentFieldset);
        }
    });

    window.onload = updateFormVisibility;
</script>